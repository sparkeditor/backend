const os = require("os");
const path = require("path");
const fs = require("fs");
const mkdirp = require("mkdirp");
const asyncForEach = require("async-for-each");
const database = require("../database");
const ConfigurationManager = require("../configurationManager");

const configurationManager = new ConfigurationManager(path.join(os.homedir(), ".spark", "config.json"));

/** The directory in which to store or symlink projects */
const projectDirectory = configurationManager.getValue("projectDirectory", path.join(os.homedir(), ".spark", "projects"));

/**
 * A project definition
 * @typedef {object} projectDefinition
 * @property {string} name - The project name
 * @property {number} [id] - The project's unique id. This can be automatically generated by the database.
 * @property {string} [root_directory] -
 *     The project's root directory. If it is not {projectDirectory}/{projectName}, then a symlink
 *     will be created from {root_directory} to {projectDirectory}/{projectName}
 */

/**
 * Generates a "does not exist" error
 * @param {string} project
 * @returns {Error}
 */
const doesNotExistError = function(project) {
    const error = new Error("Project " + project + " does not exist")
    error.code = "DOES_NOT_EXIST";
    return error;
};

/**
 * This module exposes an API to add, remove, and edit project definitions
 */
module.exports = {
    /**
     * Creates a new project
     * @param {projectDefinition} projectDefinition
     * @param {function} callback - Called with an error if any exists
     */
    createProject: function(projectDefinition, callback) {
        const rootDirectory = projectDefinition.root_directory;
        delete projectDefinition.root_directory;
        if (rootDirectory) {
            fs.access(rootDirectory, function(err) {
                if (err) {
                    return callback(err);
                }
                database.insertInto("project", projectDefinition, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    mkdirp(projectDirectory, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.symlink(rootDirectory, path.join(projectDirectory, projectDefinition.name), function(err) {
                            callback(err);
                        });
                    });
                });
            });
        }
        else {
            database.insertInto("project", projectDefinition, function(err) {
                if (err) {
                    return callback(err);
                }
                mkdirp(path.join(projectDirectory, projectDefinition.name), function(err) {
                    callback(err);
                });
            });
        }
    },
    /**
     * Retrieves a project
     * @param {number|string} project - The id or name of the project to retrieve
     * @param {function} callback - Called with the signature callback(error, project)
     */
    getProject: function(project, callback) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        database.query("project", queryDefinition, function(err, rows) {
            if (rows.length === 0) {
                return callback(doesNotExistError(project));
            }
            const project = rows[0];
            project.root_directory = path.join(projectDirectory, project.name);
            callback(err, project);
        });
    },
    /**
     * Deletes a project. This does not delete the project files, only the database entry
     * @param {number|string} project - The id or name of the project to delete
     * @param {function} callback - Called with an error if any exists
     */
    deleteProject: function(project, callback) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        database.deleteRow("project", queryDefinition, function(err) {
            callback(err);
        });
    },
    /**
     * Gets a list of users for the given project
     * @param {number} projectId - The project's id
     * @param {function} callback - Called with the signature callback(error, users).
     *                              Users is an array of user objects, with an added access_level
     *                              property denoting their access level with that project
     */
    getUsersForProject: function(projectId, callback) {
        database.query({"user": "id", "user_project": "user_id"}, {project_id: projectId}, function(err, rows) {
            if (err) {
                return callback(err);
            }
            rows.forEach(function(row) {
                delete row.user_id;
                delete row.project_id;
            });
            callback(null, rows);
        });
    },
    /**
     * Gets a list of projects for the given user
     * @param {number|string} user - The user's id or username
     * @param {function} callback - Called with the signature callback(error, projects).
     *                              Projects is an array of project objects, with an added
     *                              access_level property denoting the given user's access
     *                              level with that project
     */
    getProjectsForUser: function(user, callback) {
        if (typeof user === 'string') {
            const query = "SELECT project.*, user_project.access_level " +
                          "FROM user JOIN user_project ON user.id = user_project.user_id " +
                          "JOIN project on project.id = user_project.project_id " +
                          "WHERE user.username = '" + user + "'";
            database.getDB().all(query, function(err, rows) {
                callback(err, rows);
            });
        }
        else if (typeof user === 'number') {
            database.query({"project": "id", "user_project": "project_id"}, {user_id: user}, function(err, rows) {
                if (err) {
                    return callback(err);
                }
                rows.forEach(function(row) {
                    delete row.user_id;
                    delete row.project_id;
                });
                callback(null, rows);
            });

        }
        else {
            return callback(new Error("user must be a string or a number"));
        }
    },
    /**
     * Gets the project id of a file
     * @param {string} filepath - the absolute path of the file
     * @param {function} callback - called with the signature callback(error, projectId)
     */
    getProjectForFile: function(filepath, callback) {
        // TODO normalize filepath to use OS-specific delimiters
        // Is the filepath pointing to a project directory or an external directory?
        if (path.dirname(filepath).contains(projectDirectory)) {
            // The path is in a project directory - which one?
            const pathParts = path.dirname(filepath).split(path.sep);
            const projectName = pathParts[pathParts.length - 1];
            this.getProject(projectName, function(err, project) {
                callback(err, project.id);
            });
        }
        else {
            // The path is not a project directory - which project directory is a symlink to the path?
            fs.readdir(projectDirectory, function(err, files) {
                if (err) {
                    callback(err);
                }
                else {
                    let projectName;
                    asyncForEach(files, function(file, index, next) {
                        fs.lstat(file, function(err, stats) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                if (stats.isSymbolicLink()) {
                                    fs.readlink(file, function(err, linkTarget) {
                                        if (linkTarget === filepath) {
                                            // Found it!
                                            const pathParts = file.split(path.sep);
                                            projectName = pathParts[pathParts.length - 1];
                                            this.getProject(projectName, function(err, project) {
                                                callback(err, project.id);
                                            });
                                        }
                                        else {
                                            next();
                                        }
                                    });
                                }
                                else {
                                    next();
                                }
                            }
                        });
                    }, function(err) {
                        if (err) {
                            callback(err);
                        }
                        else if (!projectName) {
                            callback(new Error("ENOENT"));
                        }
                    });
                }
            });
        }
    }
};