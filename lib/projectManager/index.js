const os = require("os");
const path = require("path");
const fs = require("fs");
const mkdirp = require("mkdirp");
const database = require("../database");
const ConfigurationManager = require("../configurationManager");

const configurationManager = new ConfigurationManager(path.join(os.homedir(), ".spark", "config.json"));

/** The directory in which to store or symlink projects */
const projectDirectory = configurationManager.getValue("projectDirectory", path.join(os.homedir(), ".spark", "projects"));

/**
 * A project definition
 * @typedef {object} projectDefinition
 * @property {string} name - The project name
 * @property {number} [id] - The project's unique id. This can be automatically generated by the database.
 * @property {string} [root_directory] -
 *     The project's root directory. If it is not {projectDirectory}/{projectName}, then a symlink
 *     will be created from {root_directory} to {projectDirectory}/{projectName}
 */

/**
 * Generates a "does not exist" error
 * @param {string} project
 * @returns {Error}
 */
const doesNotExistError = function(project) {
    const error = new Error("Project " + project + " does not exist")
    error.code = "DOES_NOT_EXIST";
    return error;
};

/**
 * This module exposes an API to add, remove, and edit project definitions
 */
module.exports = {
    /**
     * Creates a new project
     * @param {projectDefinition} projectDefinition
     * @param {function} callback - Called with an error if any exists
     */
    createProject: function(projectDefinition, callback) {
        const rootDirectory = projectDefinition.root_directory;
        delete projectDefinition.root_directory;
        if (rootDirectory) {
            fs.access(rootDirectory, function(err) {
                if (err) {
                    return callback(err);
                }
                database.insertInto("project", projectDefinition, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    mkdirp(projectDirectory, function(err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.symlink(rootDirectory, path.join(projectDirectory, projectDefinition.name), function(err) {
                            callback(err);
                        });
                    });
                });
            });
        }
        else {
            database.insertInto("project", projectDefinition, function(err) {
                if (err) {
                    return callback(err);
                }
                mkdirp(path.join(projectDirectory, projectDefinition.name), function(err) {
                    callback(err);
                });
            });
        }
    },
    /**
     * Retrieves a project
     * @param {number|string} project - The id or name of the project to retrieve
     * @param {function} callback - Called with the signature callback(error, project)
     */
    getProject: function(project, callback) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        database.query("project", queryDefinition, function(err, rows) {
            if (rows.length === 0) {
                return callback(doesNotExistError(project));
            }
            callback(err, rows[0]);
        });
    },
    /**
     * Deletes a project. This does not delete the project files, only the database entry
     * @param {number|string} project - The id or name of the project to delete
     * @param {function} callback - Called with an error if any exists
     */
    deleteProject: function(project, callback) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        database.deleteRow("project", queryDefinition, function(err) {
            callback(err);
        });
    },
    /**
     * Gets a list of users for the given project
     * @param {number} projectId - The project's id
     * @param {function} callback - Called with the signature callback(error, users).
     *                              Users is an array of user objects, with an added access_level
     *                              property denoting their access level with that project
     */
    getUsersForProject: function(projectId, callback) {
        database.query({"user": "id", "user_project": "user_id"}, {project_id: projectId}, function(err, rows) {
            if (err) {
                return callback(err);
            }
            rows.forEach(function(row) {
                delete row.user_id;
                delete row.project_id;
            });
            callback(null, rows);
        });
    },
    /**
     * Gets a list of projects for the given user
     * @param {number|string} user - The user's id or username
     * @param {function} callback - Called with the signature callback(error, projects).
     *                              Projects is an array of project objects, with an added
     *                              access_level property denoting the given user's access
     *                              level with that project
     */
    getProjectsForUser: function(user, callback) {
        if (typeof user === 'string') {
            const query = "SELECT project.*, user_project.access_level " +
                          "FROM user JOIN user_project ON user.id = user_project.user_id " +
                          "JOIN project on project.id = user_project.project_id " +
                          "WHERE user.username = '" + user + "'";
            database.getDB().all(query, function(err, rows) {
                callback(err, rows);
            });
        }
        else if (typeof user === 'number') {
            database.query({"project": "id", "user_project": "project_id"}, {user_id: user}, function(err, rows) {
                if (err) {
                    return callback(err);
                }
                rows.forEach(function(row) {
                    delete row.user_id;
                    delete row.project_id;
                });
                callback(null, rows);
            });

        }
        else {
            return callback(new Error("user must be a string or a number"));
        }
    }
};