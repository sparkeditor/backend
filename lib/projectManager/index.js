const Promise = require("bluebird");
const os = require("os");
const path = require("path");
const fs = require("fs");
const mkdirp = require("mkdirp");
const asyncForEach = require("async-for-each");
const database = require("../database");
const ConfigurationManager = require("../configurationManager");

Promise.promisifyAll(fs);
const mkdirpAsync = Promise.promisify(mkdirp);

const configurationManager = new ConfigurationManager(path.join(os.homedir(), ".spark", "config.json"));

/** The directory in which to store or symlink projects */
const projectDirectory = configurationManager.getValue("projectDirectory", path.join(os.homedir(), ".spark", "projects"));

/**
 * A project definition
 * @typedef {object} projectDefinition
 * @property {string} name - The project name
 * @property {number} [id] - The project's unique id. This can be automatically generated by the database.
 * @property {string} [root_directory] -
 *     The project's root directory. If it is not {projectDirectory}/{projectName}, then a symlink
 *     will be created from {root_directory} to {projectDirectory}/{projectName}
 */

/**
 * Generates a "does not exist" error
 * @param {string} project
 * @returns {Error}
 */
const doesNotExistError = function(project) {
    const error = new Error("Project " + project + " does not exist")
    error.code = "DOES_NOT_EXIST";
    return error;
};

/**
 * This module exposes an API to add, remove, and edit project definitions
 */
module.exports = {
    /**
     * Creates a new project
     * @param {projectDefinition} projectDefinition
     * @returns {Promise}
     */
    createProject: function(projectDefinition) {
        const rootDirectory = projectDefinition.root_directory;
        delete projectDefinition.root_directory;
        if (rootDirectory) {
            return fs.accessAsync(rootDirectory)
                .then(() => database.insertInto("project", projectDefinition))
                .then(() => mkdirpAsync(projectDirectory))
                .then(() => fs.symlinkAsync(rootDirectory, path.join(projectDirectory, projectDefinition.name)));
        }
        else {
            return database.insertInto("project", projectDefinition).then(() => mkdirpAsync(path.join(projectDirectory, projectDefinition.name)));
        }
    },
    /**
     * Retrieves a project
     * @param {number|string} project - The id or name of the project to retrieve
     * @returns {Promise}
     */
    getProject: function(project) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        return database.query("project", queryDefinition)
            .then((rows) => {
                if (rows.length === 0) {
                    throw doesNotExistError(project);
                }
                const project = rows[0];
                project.root_directory = path.join(projectDirectory, project.name);
                return project;
            });
    },
    /**
     * Deletes a project. This does not delete the project files, only the database entry
     * @param {number|string} project - The id or name of the project to delete
     * @returns {Promise}
     */
    deleteProject: function(project) {
        let queryDefinition;
        if (typeof project === 'number') {
            queryDefinition = {id: project};
        }
        else {
            queryDefinition = {name: project};
        }
        return database.deleteRow("project", queryDefinition);
    },
    /**
     * Gets a list of users for the given project
     * @param {number} projectId - The project's id
     * @returns {Promise} - Resolves with either aan array of user objects, with an added access_level
     *                      property denoting their access level with that project, or an error
     */
    getUsersForProject: function(projectId) {
        return database.query({"user": "id", "user_project": "user_id"}, {project_id: projectId})
            .then((rows) => {
                rows.forEach(function(row) {
                    delete row.user_id;
                    delete row.project_id;
                });
                return rows;
            });
    },
    /**
     * Gets a list of projects for the given user
     * @param {number|string} user - The user's id or username
     * @returns {Promise} - Resolves with an array of project objects, with an added
     *                      access_level property denoting the given user's access level
     *                      with that project, or an error
     */
    getProjectsForUser: function(user) {
        if (typeof user === 'string') {
            const query =
                "SELECT project.*, user_project.access_level " +
                "FROM user JOIN user_project ON user.id = user_project.user_id " +
                "JOIN project on project.id = user_project.project_id " +
                "WHERE user.username = '" + user + "'";
            return new Promise(function(resolve, reject) {
                database.getDB().all(query, function(err, rows) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(rows);
                    }
                });
            });
        }
        else if (typeof user === 'number') {
            return database.query({"project": "id", "user_project": "project_id"}, {user_id: user})
                .then((rows) => {
                    rows.forEach(function(row) {
                        delete row.user_id;
                        delete row.project_id;
                    });
                    return rows;
                });
        }
        else {
            return Promise.reject(new Error("user parameter must be a string or a number"));
        }
    },
    /**
     * Gets the project id of a file
     * @param {string} filepath - the absolute path of the file
     * @returns {Promise} - Resolves with the project id, undefined, or an error
     */
    getProjectForFile: function(filepath) {
        // If the file does not exist, resolve undefined
        // Check if file is in a project directory or an external directory
        // case PROJECT DIRECTORY:
        //   The project name can be found by projectDirectory/<project name>
        // case EXTERNAL DIRECTORY:
        //   Figure out which project directory symlinks to the external directory:
        //     for each directory in projectDirectory:
        //       if the directory is a symlink:
        //          does the filepath contain the symlink path
        const self = this;
        return fs.accessAsync(filepath)
            .then(() => {
                // The file exists!
                if (filepath.includes(projectDirectory)) {
                    // The file is in the project directory - the project name can be found by projectDirectory/<project name>
                    // Remove the "<projectDirectory>/" from the beginning of the filepath,
                    // and the first value left before the path seperator is the project name
                    const projectName = filepath.replace(projectDirectory + path.sep, "").split(path.sep)[0];
                    return self.getProject(projectName).then((project) => project.id);
                }
                else {
                    // The file is in an external directory - which project directory folder symlinks to that external directory?
                    return fs.readdirAsync(projectDirectory)
                        .filter(function(projectDir) {
                            projectDir = path.join(projectDirectory, projectDir);
                            return fs.lstatAsync(projectDir)
                                .then((stats) => {
                                    if (stats.isSymbolicLink()) {
                                        return fs.readlinkAsync(projectDir).then((linkTarget) => filepath.includes(linkTarget));
                                    }
                                    else {
                                        return false;
                                    }
                                })
                        })
                        .then((matchingProjects) => {
                            if (matchingProjects.length > 1) {
                                throw new Error("Found more than one matching project based on symlink paths");
                            }
                            if (matchingProjects[0]) {
                                return self.getProject(matchingProjects[0]).then((project) => project.id);
                            }
                            // Implicit else - resolve undefined if no matching projects found
                        });
                }
            })
            .catch((err) => {
                // If the file does not exist - resolve undefined by swallowing error
                if (err.code !== "ENOENT") {
                    throw err
                }
            });
    }
};